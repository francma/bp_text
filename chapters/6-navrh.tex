\chapter{Návrh systému}

V této kapitole se budeme věnovat návrhu systému, konkrétně: 

\begin{itemize}
	\item architektura systému,
	\item průběh integrace,
	\item komunikace systému,
	\item komunikace s běhovým prostředím,
	\item persistence dat,
	\item výběr programovacího jazyka pro implementaci a knihoven,
	\item terminálového rozhraní,
	\item webového rozhraní.
\end{itemize}

V následujícím textu bude odkazováno na navrhovaný systém jeho vybraným názvem -- Piper~CI.
Inspirací pro jméno je firma Pied Piper z TV seriálu Sillicon Valley \cite{pied_piper}.

\section{Architektura}

Při výběru architektury systému by měl být brán v potaz požadavek na jeho modulárnost.
Jelikož u monolitického systému by dosažení modulárnosti byl problém, tak je vhodnější zvolit systém distribuovaný.

\section{Komunikace}

Jelikož Piper CI není architektonicky navržen jako monolit, ale jako modularní systém s více nezávislími částmi, tak je nutné zajistit komunikaci těchto jednotlivých částí.
V následující podkapitole budou probrány možné přístupy k vyřešení tohoto problému.

\subsection{REST architektura}

Za REST kompatibilní rozhraní je považováno rozhraní splňující následující požadavky:

\begin{itemize}
	\item model klient-server,
	\item bezstavový model,
	\item správa mezipaměťi,
	\item uniformní rozhraní,
	\item vrstvená architektura. \cite{rest}
\end{itemize}

\subsubsection{Model klient-server}

Model klient-server je styl návhru systému, který dělí jeho části na poskytovatele služeb (servery) a jejich uživatele (klienty).
Rozdělením systému na více (na sobě nezávislých) částí je docíleno vylepšené portabtability a škálovatelnosti.
\cite{rest_klient_server}

\subsubsection{Bezstavový model}

Bezstavové odbavení požadavku znamená, že každý požadavek musí obsahovat všechny informace k jeho vyřízení.
Přínosem je jednodušší odbavení požadavku z hlediska serveru, který nemusí udržovat jednotlivým klientům jejich stav (\textit{session}) nebo řešit chyby na základě nevalidního stavu.
Nevýhoda spočívá v redundanci přenesených dat.
\cite{rest_bezstavovy}

\subsubsection{Správa mezipaměti}

Součástí odpovědi od serveru může být i informace o tom, zda je možné tuto odpověď znovupoužít.
Klient pak místo posílání dalšího stejného požadavku může použít již obdrženou odpověď z mezipaměti.
Výhodou je uvolnění systémových prostředků serveru.
Na druhé straně se může stát, že odpověd v mezipaměti je již neplatná.
\cite{rest_mezipamet}

\subsubsection{Uniformní rozhraní}

Rozhraní serveru je navrženo obecně, bez přizpůsobení požadavkům jednoho určitého klienta.
Tímto je dosaženo zjednodušení serverové části za cenu snížení efektivity.
\cite{rest_uniformni}

\subsubsection{Vrstvená architektura}

Příjemce požadavku a jeho vykonavatel nemusí být tentýž server.
Z hlediska klienta se v komunikaci se serverem nic nemění.
Nevýhodou je zvýšení režie a latence přenosu dat.
Přínos spočívá v umožnění rozdělení serverové části na více menších systémů, které jsou snažší na správu a umožňují lepší škálovatelnost.
\cite{rest_architektura}

\subsubsection{Reprezentace dat a přístup ke zdrojům}

Základním stavebním kamenem REST rozhraní jsou zdroje.
Každá pojmenovatelná informace může být zdrojem (např. počasí dnes v Praze, \ldots), kolekce dalších zdrojů (např. počasí v hlavních městech Evropy) a další.
Zdroj je identifikován URI adresou\footnote{schéma:[//[uživatel[:heslo]@]server[:port]][/cesta][?dotaz][\#fragment]}.
\cite{rest_zdroje}

\subsection{Příklad realného použití}

Mějme server, který disponuje HTTP REST API s kolekcemi \verb|/projekty|, \verb|/integrace|.
Klientem bude jednoduché webové rozhraní, které zobrazí detaily o projektu a všechny jeho integrace.
Tím pádem klient bude potřebovat poslat 2 HTTP požadavky.
První bude na zdroj \verb|/projekty/[id_projetu]|, aby získal informace o projektu a druhý bude na \verb|/projekty/[id_projektu]/integrace|, aby získal informace o integracích k danému projektu.

Z příkladu lze vyčíst, že klient potřebuje poslat 2 dotazy na server.
To nám přináší zvýšenou režii při připojování k severu.
Ač je REST rozhraní většinou spojováno s protokolem HTTP, tak tomu tak nemusí být \cite{rest_http}.

\subsection{GraphQL}

GraphQL se snaží doplnit nedostatky REST rozhraní.
Kontrétně REST rozhraní nespecifikuje pokročilou filtraci dat a neumožňuje výběr dat z více zdrojů v jednom požadavku.
Nevýhodou GraphQL oproti REST rozhraní bude jeho větší složitost převážně na straně serveru.
\cite{graphql}

\subsection{Vzdálené volání procedur (RPC)}

Vzdálené volání procedur je v principu velmi podobné volání procedur v rámci programu.
Rozdílem je, že klientem volaná procedura je zpracovávána na vzdáleném serveru namísto, aby byla provedena ve stejném paměťovém adresovém prostoru.
Parametry procedury je nutné zabalit do formátu vhodného pro přenost (tzv. mashalling) a následně je zase rozbalit (tzv. unmashalling).
\cite{rpc}

\subsection{SOAP}

SOAP je komunikační protokol založený na formátu XML, jehož přenos zpráv probíhá pomocí protokolu HTTP, ale není to pravidlem \cite{soap}.
Formát komunikace je popsán WSDL souborem \cite{wsdl}.
Programovací jazyky jsou pak schopny z tohoto WSDL souboru generovat přímo klientskou část, bez nutnosti manuální definice rozhraní \cite{php_wsdl}.

\section{Komunikace v realném čase}

Pro zaručení co největší uživatelské přívětivosti by bylo vhodné, aby webové rozhraní CI systému umělo zobrazit některé informace ihned jakmile budou dostupné, bez nutnosti manuálně vyvolat obnovení dat.
Server tedy posílá pouze žádané informace a ne celou webovou stránku.
Jedná se například o~stavy buildů nebo výpis výstupu aktuálně běžícího buildu (tzv. \uv{streaming logu}).
Klientem je v~této komunikaci webový prohlížeč a serverem CI systém.

\subsection{Short-polling}

Spočívá v~opakovaném dotazování ze směru klienta (webového prohlížeče) směrem k~serveru (CI systém) v~určitém časovém intervalu.
Nevýhoda tkvý v~plýtvání systémových prostředků z~důvodu velkého počtu dotazů.
Výhodou je velmi jednoduchá implementace.


\begin{listing}[ht]
\begin{minted}[frame=single, linenos]{text}
00:00:00 Klient -> Máš pro mě něco?
00:00:01 Server -> Ne, čekej.
00:00:01 Klient -> Máš pro mě něco?
00:00:02 Server -> Ne, čekej.
00:00:02 Klient -> Máš pro mě něco?
00:00:03 Server -> Ano. Tady to je!
\end{minted}
\caption{Short polling}
\end{listing}

K~uskutečnění dotazu ze směru prohlížeče využijeme JavaScript a jeho třídu \verb|XMLHttpRequest| nebo Fetch API \cite{fetch_api}.
Z pohledu strany serveru se jedná o~klasický HTTP požadavek.

\subsection{Long-polling}

Server po přijmutí požadavku místo okamžité záporné odpovědi čeká dokud nemůže vratít požadovaná data nebo je nucen poslat spojení ukončit z důvodu vypršení spojení (\textit{timeout}).

\begin{listing}[ht]
\begin{minted}[frame=single, linenos]{text}
00:00:00 Klient -> Máš pro mě něco?
00:00:15 Server -> Ano.
00:00:15 Klient -> Máš pro mě něco?
\end{minted}
\caption{Long polling}
\end{listing}

Implementace témeř totožná s~short-pollingem.
Rozdílem je přidání čekací smyčky na straně serveru.

\subsection{Server-Sent Events}

Jednostranné spojení ve směru od serveru ke klientovi.
Oproti long-pollingu není nutné stále otevírat nová spojení, drží se stále jedno.
Spojení, které nekončí chybou, jsou automaticky znovuotevírána.

\begin{listing}[ht]
\begin{minted}[frame=single, linenos]{text}
00:00:00 Klient -> Posílej mi všechno!
00:00:15 Server -> Tady to je.
00:00:16 Server -> Tady to je.
\end{minted}
\caption{SSE}
\end{listing}

\noindent
Serverová implementace založena na HTTP se speciální \verb|Content-Type| hlavičkou.
Jednotlivé zprávy jsou identifikovány pomocí pole \verb|id| a odřádkováním.
\cite{sse}

\begin{listing}[ht]
\begin{minted}[frame=single, linenos]{text}
Content-Type: text/event-stream
Cache-Control: no-cache

id: <id zpravy>
data: <data>

id: <id zpravy>
data: <data>
\end{minted}
\caption{SSE struktura komunikace}
\end{listing}

O~příjem komunikace na straně klienta se stará JavaScript třída \verb|EventSource| \cite{sse_event_source}.

\subsection{Websocket}

Oboustranné spojení mezi klientem a serverem.
Prvnotní požadavek přes HTTP protokol se změnou na WebSocket spojení.
Většína jazyků určených pro vývoj webových aplikací nemá podporu WebSocketů přímo zabudovanou a tak je nutnost sáhnout po knihovně třetí strany.
Implementace na straně webového prohlížeče implementována pomocí JavaScript třídy \verb|WebSocket|.
\cite{websocket}

\subsection{HTTP2}


\section{Komuninakce s~běhovým prostředím}

Cílem je vytvořit rozhraní s běhovým prostředím, které přijme zadaný příkaz nebo jejich sadu a poskytne přístup k průběžnému výstupu.
Pokud budeme vykonávat jednotlivé příkazy odděleně, tak je nutné zajistit persistenci prostředí uvnitř běhového prostředí.
Například pokud jeden příkaz nadefinuje proměnné prostředí, tak další příkaz by k nim měl mít přístup (například změna pracovní složky \verb|$PWD|).

\subsection{Virtualbox}

Jelikož se jedná o plnou virtualizaci, tak je potřeba vytvořit jakýsi můstek mezi hostem a hostitelem.

\subsubsection{COM port pro čtení/zápis}

Pomocí VirtualBox administračního rozhraní vytvoříme COM port, jehož výstup nasměrujeme do souboru nebo sockeru na hostitelském systému.
Každý spuštěný příkaz poté přesměrujeme na zvolený COM port a aplikace provozovaná na hostitelském systému tento výstup převezme.
Spojení je oboustranné, takže je možné předávat příkazy i do hostovaného systému.
\cite{virtualbox_serial}

\subsubsection{SSH spojení}

SSH je kryptografický protokol, který umožňuje oboustrannou komunikaci mezi účastníky \cite{ssh_rfc}.
Přihlášení uživatele do systému je implementováno na základě věřejného klíče, hesla, hostname nebo lze ověřování úplně vypnout \cite{ssh_auth_rfc}.
Pro naše účely lze ověřované úplně vypnout za předpokladu, že dokažeme ohlídat možné zneužití.

\subsection{Docker}

Příkazy lze předávat do kontejneru přímo z~hostujícího stroje.
Výstup z příkazů pak jednoduše směrujeme do souboru nebo socketu.

\begin{listing}[ht]
\begin{minted}[frame=single,linenos]{shell}
docker start [jmeno_kontejneru]
docker exec -i [jmeno_kontejneru] [prikaz] >> [soubor]
\end{minted}
\caption{Předání výstupu z Docker kontejneru}
\end{listing}

Pro využití přímo v našem programu můžeme využít jednu z mnoha SDK knihoven \cite{docker_sdk}.

\subsection{LXD}

Jádro LXD je proces běžící na pozadí, který zpřístupňuje svoji funkcionalitu skrze REST API dostupné přes lokální unix socket nebo síť \cite{lxd}.
Klientem může být naše vlastní implementace podle REST API specifikace nebo využijeme předpřipravené klienty \cite{lxd_rest}.

\begin{listing}[ht]
\begin{minted}[frame=single,linenos]{shell}
curl -k -L --cert cert --key key "https://localhost:8443/1.0/images"
\end{minted}
\caption{Dotaz na REST API pomocí HTTP}
\end{listing}

\section{Persistence dat}

V následující sekci probereme možnosti způsobu persistence dat.
Nejprve je ale nutné definovat jaké druhy dat je třeba ukládat.
Budou to například:

\begin{itemize}
	\item uživatelé a jejich nastavení,
	\item výsledky buildů včetně jejich výstupů,
	\item fronty,
	\item dočasná data (cache),
	\item vazby mezi CI a SCM.
\end{itemize}

Data by měla být i jednoduše seřaditelná podle různých kritérií.

\subsection{Souborový systém}

Nejjednodušší persistentní datové uložiště, které lze strukturovat pomocí adresářů a symbolických odkazů.
Jednotlivé soubory pak uložíme v~nějakém strojově zpracovatelném formátu, například JSON, YAML nebo XML.
Z~hlediska složité filtrace a řazení nevhodné pro data nad kterými chceme provádět tyto operace.
Vhodné pro:
\begin{itemize}
	\item textové logy,
	\item binární data,
	\item velké soubory,
	\item konfigurační soubory.
\end{itemize}

\subsection{In-memory datová struktura (Redis)}

Asociativní struktura uložená v~operační paměti podporující následující datové typy:

\begin{itemize}
	\item řetězce,
	\item seznamy,
	\item sady,
	\item seřazené sady,
	\item hashe (asociativní pole).
\end{itemize}

Asociativní pole lze zanořovat do sebe a tím vytvářet struktury.
Funguje na principu klient-server a je tedy snadné sdílet data mezi více systémy, které běží například na různých strojích.
Jelikož je celá struktura uložená pouze v operační paměti, tak se ztrátou napětí ztratí i všechna uložena data.
Vhodné pro:

\begin{itemize}
	\item dočasná data ke kterým potřebujeme rychlý přístup,
	\item fronty,
	\item zámky.
\end{itemize}
\cite{redis}

\subsection{Databáze}

Vhodné pro:

\begin{itemize}
	\item filtrovaná data,
	\item řazená data,
	\item data se složitějšími vazbami.
\end{itemize}

