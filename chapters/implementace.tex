\chapter{Implementace}

Všechny části systému (core, web, runner) jsou implementovány jako Python balíčky, které je možné nainstalovat přes balíčkovací manažer pip.

\section{Jádro (Piper CI core)}


\subsection{Návrh a implementace tříd systému}

\imagefigurelarge{core.pdf}{Vnitřní architektura systému}

Aby se během programování zamezilo duplikace kódu z důvodu dvou různých přístupů k datům systému, tak byla vytvořila sada tříd (fasády) zodpovědná za veškeré operace nad entitami.
Jedna fasáda odpovídá jedné entitě.
S fasádami pak spolupracuje Flask aplikace, tak i shell aplikace.

Flask aplikace je dále rozdělena na tzv. \uv{blueprinty}, kde každý reprezentuje jeden REST API koncový bod (ukázka kódu \ref{code:piper-core-blueprint}).

\begin{listing}[ht]
\caption{\label{code:piper-core-blueprint}Implementace koncového bodu REST API}
\begin{minted}[frame=single,linenos]{python}
@builds_view.route(
    '/builds',
    methods=['GET']
)
@builds_view.route(
    '/projects/<int:project_id>/builds',
    methods=['GET']
)
@query_parse
@authorize
def builds_view_list(filters, order, limit, offset, user, project_id):
    if project_id is not None:
        filters['project_id'] = project_id
    result = facade.list(user, filters, order, limit, offset)

    return flask.jsonify(result)
\end{minted}
\end{listing}

Celá aplikace je pak zapouzdřena v tzv. \uv{kontejneru}, který se stará o provázání závislostí mezi jednotlivými třídami a jejich konfiguraci uživatelem (například předání parametrů pro připojení k databázi).

\subsection{Dokumentace a validace API}

Dokumentace je napsaná v OpenAPI schématu, které staví na JSON Schema.
Tím pádem vytvořená dokumentace slouží také podklad pro validaci vstupních dat.

\subsection{Napojení na GitHub}

Jedná se o zpracování tzv. \uv{webhooků}, což je HTTP požadavek z GitHub serveru směrem k jádru Piper CI.
GitHub požadavek vytváří při změně v repozitáře (\textit{git push}).
Nám stačí pak tento požadavek zpracovat, stáhnout \verb|piper.yml| soubor a vytvořit novou integraci.

Jiné systémů se opírají o stejné principy a tak jejich implementace není problémem.

\section{Běhový klient (Piper CI LXD runner)}

Běhový klient je založený na LXD kontejnerech a dovoluje vnitřně spouštět několik souběžných úkolů pomocí knihovny multiprocessing.
K zajištění úklidu kontejneru za každých okolností je využito Python konstrukce \verb|with| (ukázka kódu \ref{code:piper-runner-with}).

\begin{listing}[ht]
\caption{\label{code:piper-runner-with}Využití konstrukce with pro smazání kontejneru}
\begin{minted}[frame=single]{python}
class Script:

    def __enter__(self):
        # Vytvoř kontejner
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Smaž kontejner
        pass

with Script(config) as script:
    # I když tato metoda povede k neošetřené vyjímce
    # tak Script zavolá __exit__ a kontejner se smaže
    script.run()
\end{minted}
\end{listing}

Běhový klient je schopen v rámci jedné své instance spouštět více úkolů paralelně.
K paralelizaci je použita knihovna multiprocessing.

Během implementace se objevil problém, kdy vytvořený kontejner neměl prvním pár sekund přístup k síti z důvodu přidělování údajů k síti přes DHCP.
Problém je vyřešen pomocí aktivního čekání na přidělení výchozí routy (ukázka kódu \ref{code:piper-runner-job-wait}).

\begin{listing}[ht]
\caption{\label{code:piper-runner-job-wait}Čekání na síť uvnitř kontejneru}
\begin{minted}[frame=single,linenos]{shell}
i=1; d=0
while [ $i -le 300 ]; do
    i=$(($i + 1))
    if [ -z "$(ip route get 8.8.8.8 2>/dev/null | \
        grep -v unreachable)" ]; then
        sleep 0.1; continue
    fi
    d=1; break;
done
if [ $d -eq 0 ]; then
    exit 1
fi
\end{minted}
\end{listing}

Zadaní úkolu od jádra systému je nutné přeložit na skript, který bude opatřen patřičným značkami (ukázka kódu \ref{code:piper-runner-job-script}).

\begin{listing}[ht]
\caption{\label{code:piper-runner-job-script}Výsledek překladu zadání jádra systému na spustitelný skript}
\begin{minted}[frame=single]{shell}
PIPER_GLOB_EXIT=0
if [ $PIPER_GLOB_EXIT = 0 ]; then
    printf "::piper:command:0:start:%d::\\n" `date +%s`;
    # Zadaný příkaz
    echo $A
    PIPER_PREV_EXIT=$?
fi;
if [ $PIPER_GLOB_EXIT = 0 ]; then
    PIPER_GLOB_EXIT=$PIPER_PREV_EXIT
    printf "::piper:command:0:end:%d:%d::\\n" `date +%s` \
    $PIPER_PREV_EXIT
fi;
...
exit $PIPER_GLOB_EXIT;
\end{minted}
\end{listing}

\section{Webové rozhraní (Piper CI web)}


\begin{listing}[ht]
\begin{minted}[frame=single,linenos]{javascript}
var fn = function() {
    fetch('/logs/' + job.id + '?offset=' + offset).then(
        function(response) {
            return response.text();
        }).then(function(text) {
            var str = text;
            offset += text.length;
            // provedeme nahrazení značek (::piper) za příkazy z úkolu
            ...
            // provedeme nahrazení terminálových ANSI sekvencí za HTML
            ...
            // výstup vypíšeme
            setTimeout(fn, 1000);
        }
    );
};
\end{minted}
\caption{Dotaz na REST API pomocí HTTP}
\end{listing}

\imagefigurelarge{piper-web.png}{Výsledné webové rozhraní}

