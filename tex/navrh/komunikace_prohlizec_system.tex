\sec Aktivní komunikace mezi prohlížečem a CI

Pro zaručení co největší uživatelské přívětivosti by bylo vhodné, aby webové rozhraní CI systému umělo zobrazit některé informace ihned jakmile budou dostupné, bez nutnosti manuálně vyvolat obnovení celé webové stránky.
Server tedy posílá pouze žádané informace a ne celou webovou stránku.
Jedná se například o stavy buildů nebo výpis výstupu aktuálně běžícího buildu (tzv. \uv{streaming logu}).
Klientem je v této komunikaci webový prohlížeč a serverem CI systém.

\secc Short-polling

Spočívá v opakovaném dotazování ze směru klienta (webového prohlížeče) směrem k serveru (CI systém) v určitém časovém intervalu.
Nevýhoda tkvý v plýtvání systémových prostředků z důvodu velkého počtu dotazů.
Výhodou je velmi jednoduchá implementace.

\begtt
00:00:00 Klient -> Máš pro mě něco?
00:00:01 Server -> Ne, čekej.
00:00:01 Klient -> Máš pro mě něco?
00:00:02 Server -> Ne, čekej.
00:00:02 Klient -> Máš pro mě něco?
00:00:03 Server -> Ano.
\endtt

\noindent
K uskutečnění dotazu ze směru prohlížeče využijeme JavaScript a jeho třídu {\tt XMLHttpRequest}.
Ze strany serveru se jedná o klasický HTTP GET požadavek.

\secc Long-polling

Server po přijmutí požadavku místo okamžité záporné odpovědi čeká dokud nemůže vrátit kladný výsledek.
Čekání je omezeno časovým limitem spojení na straně serveru i klienta.
Na straně serveru je nutné si pohlídat maximální počet aktivních spojení.

\begtt
12:00 00:00:00 Klient -> Máš pro mě něco?
12:00 00:00:15 Server -> Ano.
12:00 00:00:15 Klient -> Máš pro mě něco?
\endtt

\noindent
Implementace témeř totožná s Short-pollingem.
Rozdílem je přidání čekací smyčky na straně serveru.

\secc Server-Sent Events

Jednostranné spojení ve směru od serveru ke klientovi.
Oproti long-pollingu není nutné stále otevírat nová spojení, drží se stále jedno.
Spojení, které nekončí chybou, jsou automaticky znovuotevírána.

\begtt
12:00 00:00:00 C -> Posílej mi všechno!
12:00 00:00:15 S -> Tady to je.
12:00 00:00:16 S -> Tady to je.
\endtt

\noindent
Serverová implementace založena na HTTP se speciální {\tt Content-Type} hlavičkou.
Jednotlivé zprávy jsou identifikovány pomocí pole {\tt id} a odřádkováním.

\begtt
Content-Type: text/event-stream
Cache-Control: no-cache

id: <id zpravy>
data: <data>

id: <id zpravy>
data: <data>
\endtt

\noindent
O příjem komunikace na straně klienta se stará JavaScript třída {\tt EventSource}.

\secc Websocket

Oboustranné spojení mezi klientem a serverem.
Prvnotní požadavek přes HTTP protokol se změnou na WebSocket spojení.
Většína jazyků určených pro vývoj webových aplikací nemá podporu WebSocketů přímo zabudovanou a tak je nutnost sáhnout po knihovně třetí strany.
Implementace na straně webového prohlížeče implementována pomocí JavaScript třídy {\tt WebSocket}.

\secc Závěr

Nejsilnějším nástrojem jsou zajisté WebSockety.
Nicméně naše použití nepotřebuje plnou oboustrannou komunikaci a z hlediska implementace jsou WebSockety tou nejsložitější cestou.
Nejvýhodnějším řešením je technologie SSE, nepotřebuje žádné další externí závislosti a implemetace na serverové straně je velmi jednoduchá.