\chapter{Gitlab CI}

\section{Uživatelské použití}

Konfigurace projektů je řešena pomocí souboru \verb|.gitlab-ci.yml|, který je umístěn přímo v~kořenovém adresáři repozitáři projektu.

\section{Průběh integrace}

Proces integrace je rozdělen na fáze (\textit{stages}), úkoly (\textit{jobs}) a příkazy.
Fáze se vykonávají sekvenčně za sebou v~zadaném pořadí.
Pokud jedna z~fází selže, tak celý proces integrace končí chybou.

\begin{minted}[
    frame=single,
    linenos
  ]{yaml}
stages:
  - test
  - build
  - deploy
\end{minted}

Jednotlivé fáze se skládají z~několika úkolů.
Ůkoly jsou spouštěny nezávisle na sobě a tím pádem je lze paralelizovat.
Selhání jednoho z~úkolů vede k~neuspěchu celé fáze.
Úkoly jsou vždy provedeny všechny, nezávisle na výsledku ostatních v~rámci fáze.


\begin{minted}[
    frame=single,
    linenos
  ]{yaml}
job1:
  stage: test
  script:
    - cmd 1
    - cmd 2
\end{minted}

Každý úkol je složen z~několika příkazů.
Pokud jeden z~příkazů skončí chybovým návratovým kódem, pak je ukončeno provádění úkolu.

Mezi speciální úkoly patří \verb|before\_script| a \verb|after\_script|.
Tyto úkoly jsou provedeny vždy před nebo po každým uživatelsky definovaným úkolem.

\begin{minted}[
    frame=single,
    linenos
  ]{yaml}
before_script:
  - cmd 1
  - cmd 2

after_script:
  - cmd 1
  - cmd 2
\end{minted}

Jednotlivým úkolům lze přiřadit podmínečné spuštění pomocí notace \verb|when|.

\begin{itemize}
  \item \verb|on\_success| -- vykonej pouze pokud předchozí fáze skončila úspěchem (výchozí) 
  \item \verb|on\_failure| -- vykonej pouze pokud předchozí fáze skončila neúspěchem
  \item \verb|always| -- vykonej vždy
\end{itemize}

\section{Architektura}

% \centerline {\picwidth=\hsize \inspic img/gitlab_architecture_diagram.png }
% \label[my-pic]
% \nobreak
% \caption/f Gitlab Architektura

% https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/development/architecture.md

\subsection{NGINX a Gitlab Pages}

Frontend aplikace. Úloha NGINX jako reverzní proxy z~hlediska cachování je předávána spíše na Gitlab Workhorse.
Stará je o~šifrování venkovního spojení pomocí HTTPs.

\subsection{Gitlab Workhorse}

Prvotním úkolem bylo podržet dlouhotrvající HTTP spojení vytvořeném GIT clonem přes HTTP a ne SSH.
Důvodem pro to bylo, že Unicorn tyto spojení po vyprchání času ukončoval a zdálo se technologicky jednodušší implementovat další vrstvu, která obslouží tyto požadavky, než měnit existující modul.
Po přidání možnosti stažení ZIP souboru s~repozitářem a vytváření tzv. artefaktů během buildu se zrodil stejná problém jako s~GITem přes HTTP a byl také vyřešen stejným způsobem.
Při dalším vývoji se zdálo moc pracné stále udržovat NGINX server, aby nějaké typy požadavků směroval na Unicorn a jiné na Workhorse, tak se začly všechny požadavky směrovat přes Workhorse.
Workhorse nyní funguje jako chytřejší proxy poskytující statické soubory, GIT přes HTTP a směruje požadavky dále do Gitlab infrastruktury.

% https://gitlab.com/gitlab-org/gitlab-workhorse
% https://about.gitlab.com/2016/04/12/a-brief-history-of-gitlab-workhorse/

\subsection{Unicorn}

Ruby HTTP server.

% nejspis hlavni server FIXME

\subsection{Gitlab shell}

Shell obsahující set příkazů pracující na originálním GITem.
Po připojení na server přes SSH je možné konfigorovat repozitáře přímo přes shell příkazy.
Řada oprávnění je kontrolována přímo přes GIT hooky, takže není nutné využívat Gitlab Shell.
Pokud se jedná o~komplexnější akci, vyžadující komplexnější kontrolu oprávnění, pak je nutné využít Gitlab Shellu.

% https://gitlab.com/gitlab-org/gitlab-shell/tree/master

\subsection{Gitaly}

Každý GIT příkaz zpracovávaný Gitlabem nakonec skončí v~Gitaly.
Cíl Gitaly je urychlit GIT příkazy decentralizováním uložiště a použitím cache.
V~současné době se uvažuje nad využitím projektu Git Ketch.
Git Ketch replikuje uložiště mezi několik serverů, u~kterých není pevně určené rozdělení na hlavní a sekundární.
Hlavní server je vybrán podle hlasování na základě aktuálnosti dat mezi servery.

% https://gitlab.com/gitlab-org/gitaly/tree/master
% https://www.infoq.com/news/2016/02/google-kick-starts-git-ketch

\subsection{Uložiště}

PostreSQL persistentní.
Cache a data broker Redis.

\subsection{Komunikace}

GRPC uvnitř Gitlab systému.


% https://gitlab.com/gitlab-org/gitaly/tree/master


\subsection{Gitlab CI multi-runner}

CI systém spolupracuje s~několika běhovými servery (\textit{Runners}), které se starají o~samotné vykonání definovaných příkazů (sestavení).
Běhové servery využívají exekutory.
Implementuje několik exekutorů.
Volba běhováho serveru je definována na úrovni konfigurace projektu a je omezena globálním nastavením Gitlab CI.

% https://docs.gitlab.com/ee/ci/runners/README.html
% http://docs.gitlab.com/ce/api/ci/builds.html

\subsubsection{Shell exekutor}

Příkazy provádí pod stejným uživatelem jako samotný běhový server.
Příkazy přeneseny jako soubor.

\subsubsection{Docker exekutor}

Docker je kontejnerová technologie.
Kontejnery jsou sestavovány z~Docker obrazů definující sadu dostupného softwaru.
Pro jednotlivá sestavení je vytvořena nová instance Docker kontejneru.
Volba obrazu pro sestavení a pro jednotlivé joby je definována klíčovým slovem \verb|image|.
Sestavení lze obohatit o~tzv. služby, kterými můžeme každému buildu dát k~dispozici přístup k~další Docker instanci, která bude dostupná pod zadanou hostname.
Služby lze opět konfigurovat na úrovni sestavení, tak na úrovni jobu.

\begin{minted}[
    frame=single,
    linenos
  ]{yaml}
image: ruby:2.2

services:
  - postgres:9.3

test:
  script:
  - bundle exec rake spec
\end{minted}

\subsubsection{VirtualBox a Parallels}

Virtualizační technologie.
Virtualní stroj musí podporovat Bash kompatibilní shell a být dostupný přes SSH spojení.
Virtualní stroje jsou klonovány pro udržení čistého prostředí pro sestavení a snapshotovány pro urychlení dalších sestavení.

% https://docs.gitlab.com/runner/executors/README.html

\subsubsection{SSH exekutor}

Podobné jako Shell exekutor, jen je využito SSH spojení.

\subsection{Cachování}

Ve výchozím stavu je cache sdílena mezi \textit{branch} a \textit{job}.
Toto chování lze upravit nastavením klíče, který bude identifikovat danou cache.
Při tvorbě klíče lze využít předdefinované CI proměnné. 
Soubory a složky určené k~cachování uvedeme jako výčet v~konfiguraci projektu.
Cesta k~souboru je uvedená jako relativní ke kořeni projektu, cachování souborů mimo projekt není touto cestou možné. 
Cache lze také omezit pouze na soubory a složky, které nejsou verzovany GITem.

\begin{minted}[
    frame=single,
    linenos
  ]{yaml}
cache:
  key: "$CI_BUILD_NAME/$CI_BUILD_REF_NAME"
  untracked: true
  paths:
    - binaries/
    - .config
\end{minted}
 
Cache je ve výchozím nastavení ukládána přímo na běhovém serveru.
Pokud fáze běží na různých běhových serverech, tak se cache nesdílí.
Alternativně můžeme použít sdílené cachování na S3 kompatibilních serverech.
S3 je REST API, které bylo původně vytvořeno jako část Amazon services.
Toto API implementuje samotný Amazon, tak i nějaké self-hosted projekty.

% https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/merge_requests/88
% https://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html
% https://github.com/minio/minio/


