\chap Návrh architektury systému

Systém CI pod sebou bude spravovat několik Runnerů, každý Runner v~sobě bude spouštět jednotlivé exekutory.
Komunikace bude probíhat přes API.
Jakákoliv funkcionalita by měla být zprvu naimlementovaná jako API endpoint a až pak zavedena do systému.

\sec Části systému

\secc Informační rozhraní

Webové rozhraní.
Napsané ve Flasku a nějaké hipster frontend JS knihovně.

\secc Řidič

Zajišťuje komunikaci s~uživatelem, informačním rozhraním a Runnery na pevně daném protokolu.
Řidič by měl být podle vytížení Runnerů (API endpoint na Runneru) a požadovaných služeb rozhodnout, kterému Runneru práci předá.

\secc Runner

Zadaný API vstup rozparsuj pro potřeby Exekutoru a nech ho provést dané příkazy.
Runner by měl spravovat pouze jeden typ exekutoru (UNIX like).
Runner by měl běžet na samostatném stroji, aby neubíral systémové prostředky ostatním.
Runner v~sobě většinou bude spouštět více instancí Exekutoru.

\seccc Exekutor

Konečný vykonavatel příkazů. Řidič by neměl o~existenci exekutorů vědět a komunikovat pouze s~Runnery.
Exekutorem je například VirtualBox, Docker a jiné.
Samotná exekutor by měl být co nejméně modifikovaný.
Nechceme například aby VirtualBox exekutor přijímal pouze image, které mají nainstalovaný nějaký obsáhlý set závislostí.

\secc Cache

Jelikož by cache měla být sdílená mezi Runnery, pak musí fungovat jako samostatná jednotka.
Runner by měl komunikovat přímo s~cache, aby se minimalizovat počet účastníků v~přenosu často velkých souborů.
Prvnotní komunikace bude vázána se systémem (výměna adres).
Je opravdu nutné separovat Cache jako service?

\sec Komunikace s prohlížečem v realném čase

Vypisování stavu buildu v realném čase (tzv. \uv{streaming log}) a dalších inforamcích (stav buildů, runnerů) bez nutnosti obnovení okna prohlížeče.

\secc Short-polling

Spam requestů v určitém intervalu.
Náročné na prostředky z hlediska počtu requestů.

\begtt
00:00:00 C -> Is it ready? 
00:00:01 S -> No, wait.
00:00:01 C -> Is it ready?
00:00:02 S -> No, wait.
00:00:02 C -> Is it ready? 
00:00:03 S -> Yes, here it is.
00:00:03 C -> Is it ready?
\endtt

\secc Long-polling

Necháváme otevřené spojení dokud nemáme odpověď.
Náročné na prostředky.
Například u Apache serveru nám každý požadavek vytvoří čekající vlákno.
Snadné vyčerpání limitu otevřených spojení.
Dlouho trvající spojení jsou ze strany serveru, tak i klienta nebo mezicesty (proxy) ukončována.

\begtt
12:00 00:00:00 C -> Is it ready? 
12:00 00:00:15 S -> Yes, here it is.
12:00 00:00:15 C -> Is it ready?
\endtt

\secc Server-Sent Events

Jednostranné spojení ve směru od serveru ke klientovi.

\begtt
12:00 00:00:00 C -> Send me everything you have!
12:00 00:00:15 S -> Yes, here it is.
12:00 00:00:16 S -> Yes, here it is.
\endtt

\noindent
Založeno na HTTP se snadnou implemetací.
Webový prohlížeč se při uzavření spojení návratovým kódem 200 pokusí znovu připojit.
Oproti long-pollingu není nutné stále otevírat nová spojení.

\begtt
Content-Type: text/event-stream
Cache-Control: no-cache

id: <id zpravy>
data: <data>

id: <id zpravy>
data: <data>
\endtt

\secc Websocket

Oboustranné spojení mezi klientem a serverem.
Prvnotní komunikace přes HTTP s následným upgradem na WebSocket spojení.
Webové servery nemají většinou podporu WebSocketů přímo v sobě a tak je potřeba sáhnout po kniho

\secc Závěr

Jako nejvýhodnější se jeví technologie SSE, protože nevyžaduje žádné další knihovny a má dobrou podporu mezi prohlížeči.
Oboustranná komunikace není vyžadována.

\sec Vnitrosystémová komunikace

\secc GRPC

Pracuje nad JSON, XML, Protobuffers.
Podpora streamingu.
Optimalizace zpráv.
GRPC neprotlačíme do prohlížeče (jedině po překladu na Websocket), vhodné pouze pro vnitrosystémovou komunikaci.

\secc HTTP

% http://www.grpc.io/docs/tutorials/basic/python.html

\sec Fronta

Implementace distribuovaných prioritních front ve stylu producenta a konzumenta.
Použití: máme více Runnerů a chceme jim na základě jejich vytížení přiřazovat úkoly.

\secc RabbitMQ

TODO

\secc Redis

TODO

\secc Celery

Používá RabbitMQ, Redis a další jako message broker. 
Primární implementace v Pythonu.

\sec Komuninakce s~běhovým prostředím

Cílem je vytvořit rozhraní s~VM, které přijme zadaný příkaz nebo jejich sadu a rozhraní schopno streamovat výstup z~příkazů.
Rozhraní by mělo udržovat stály stav (proměnné shellu, ...).

\secc Virtualbox

\seccc COM port pro čtení/zápis

Pomocí VirtualBox administračního rozhraní vytvoříme COM port, který nasměrujeme do souboru/socketu.
Každý spuštěný příkaz poté přesměrujeme na zvolený COM port a necháme aplikaci na rodičovském stroji číst výstupy.
Spojení je oboustranné, takže je možné předávat příkazy i dovnitř stroje, které je ale nutné parsovat a předávat systému další aplikací běžící uvnitř VM.
Tento způsob předpokládá už přihlášeného uživatele.

\seccc SSH spojení

SSH je kryptografický protokol, který umožňuje oboustrannou komunikaci mezi účastníky.
Přihlašování uživatelů do VM bez hesla lze docílit uložením jejich veřejných klíčů do souboru {\it known\_hosts}.
Soubor {\it known\_hosts} je uložen v~domovském adresáři uživatele a bude nutno zajistit jeho modifikaci buďto přes dodatečné připojení VDI obrazu disku VM nebo předpřípravou systému.

\seccc Vzdálený terminál přes COM port

Podobné SSH spojení.
Nutná editace konfigurace VM systému, aby daný COM port viděl jako terminálový.
Přihlašování uživatele a spuštění příkazů za pomoci přímého vpisu/čtení ze socketu.

\secc Docker

Příkazy lze předávat do kontenejneru přímo z hostujícího stroje.
Výpis výsledku je přímo na stdout, který lze přesměrovat do roury a z té dál do CI systému.

\begtt
docker start ecstatic_perlman
docker exec -i ecstatic_perlman bash -c 'ls -al' 
\endtt
\nobreak \label[docker-minimal-example]
\caption/l Ukázka Docker exekutoru
\smallskip

\sec Perzistence dat

Co je třeba ukládat?

\begitems
* Uživatelé a jejich nastavení
* Výsledky buildů včetně jejich logů
* Nastavení běhového prostředí
\enditems

\noindent Nad čím je třeba rychle vyhledávat?
\begitems
* Spojení commitu/větve s buildem
* ...
\enditems

\noindent
Data by měla být i jednoduše seřaditelná podle různých kritérií.

\secc Souborový systém

Obyčejná datová struktura, která nepotřebuje žádné závislosti třetí strany.
Filtrace lze dosáhnout třízením souborů do složek a vytvářením symbolických linků.
Řazení souborů buď podle data vytvoření nebo jeho názvu (použijeme datum jako prefix souboru).

Limit tohoto řešení nastává při potřebě složité indexace nebo řazení.
Bylo by nutné udržovat složitou strukturu indexů u které by nekonzistence znamenala velké problémy.
Čtení a zápis ze souborového systému je o dost dražší než z operační paměti, takže pro dosažení rychlosti bychom museli zavést cache, které by pracovala s operační pamětí.
Při ukládání velkého počtu souborů do jedné složky bychom začali narážet na limitace použitého souborového systému a docházelo by k velké výkonostní degradaci.

\seccc Příklad použití

Mějme systém, který má několik uživatelů.
Každý uživatel má svoje vlastní nastavení a spravuje několik buildů, které jsou vázány na commit a větev.

Uživatelská nastavení uložíme do souboru ve složce {\tt /user/<userId>}. Soubor bude pod názvem, identifikujícím jednoznačně uživatele (například číselný index). 

Buildy uložíme podobně jako uživatelé do složky {\tt /build/<buildId>}.
Tady narazíme na problém v provázání buildu s uživatelem.
První možností je uložit informace o vlastníkovi přímo do souboru a při filtraci projít a rozparsovat všechny soubory ve složce.
Tato operace bude velice náročná a bude se vykonávat velmi často.
Druhá možnost je vytvořit další složku, například {\tt /userBuilds/<userId>/<buildId>}, kde soubor {\tt <buildId>} bude linkem do složky {\tt /build}.
Pokud bude potřeba filtrovat podle dalších kritérií, tak vytvoříme další složky se symlinky.
Nabízí se také možnost ukládat buildy přímo do složky identifikované uživatelským identifikátorem {\tt /build/<userId>/<buildId>}, ale předpokládá se nutnost filtrace buildů podle více kritérií (například podle commitu).

\seccc Závěr

Výsledné řešení by bylo příliš náročné na správu a pomalé.
Naopak je vhodné pro ukládání velkých souborů, ve kterých není třeba žádné indexace nebo k nim není přistupováno příliš často.
Ukládat lze takto například textové výstupy z buildů nebo například uživatelská nastavení (obyčejný config file je velmi snadné editovat).

\secc Redis

Klíč-hodnota struktura uložená v operační paměti omezená na následující datové typy:

\begitems
* řetězce
* seznamy
* sady
* seřazené sady
* hashe (asociativní pole)
\enditems

\noindent
Asociativní pole lze zanořovat do sebe a tím vytvářet struktury.
Funguje na principu klient-server.
Podpora replikace mezi několik strojů.

\begtt
> HMSET user:1 name John surname Doe idk 900
OK
> HGETALL user:1
1) "name"
2) "John"
3) "surname"
4) "Doe"
5) "idk"
6) "900"
> HGET user:1 name
"John"
\endtt
\nobreak \label[redis-basic-user]
\caption/l Uložení struktorovaných dat
\smallskip

\seccc Příklad použití

Podobné jako u ukládání na souborový systém, jen jsme omezeni velikostí operační paměti.
Složitější filraci možné zaručit použitím \uv{cizích klíčů}, které ale musíme sami udržovat.
Data z operační paměti bude nutné replikovat na souborový systém v podobě průběžných logů nebo vypsaním stavu paměti každých x minut na pevný disk.
Oba způsoby jsou přímo implementované v Redisu.

\seccc Závěr

Podobné jako řešení za pomoci pouze souborového systému, jen jsme získali rychlost ukládáním přímo do operační paměti z čehož nám vznikají další limitace.
Vhodné jako rychlá cache nebo systém pro správu zámků.

\secc Databáze

Snadná filtrace mezi daty.
Optimalizace v režii databázového stroje.
Persistetní z návrhu.
Existence ORM -- abstrakce jeeej!!!

\secc Závěr

Logy uložíme do souborů, strukturovaná data v databázi a cache v Redisu.

\sec Zabíjení buildů

Build nevyprodukoval žádný výstup za x minut nebo nedoběhl za y minut.

\sec Kde poběží CI?

virtualenv?
konrejner?
